var D=Object.defineProperty,U=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var N=Object.prototype.hasOwnProperty,y=Object.prototype.propertyIsEnumerable;var p=(a,e,r)=>e in a?D(a,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):a[e]=r,m=(a,e)=>{for(var r in e||(e={}))N.call(e,r)&&p(a,r,e[r]);if(T)for(var r of T(e))y.call(e,r)&&p(a,r,e[r]);return a},c=(a,e)=>U(a,C(e));var d=(a,e,r)=>(p(a,typeof e!="symbol"?e+"":e,r),r);var b={properties:{roomId:{type:"number"},strRoomId:{type:"string"}}},l={name:"option",required:!0,properties:c(m({},b.properties),{userId:{type:"string"}})},R={name:"option",required:!0,properties:{updateList:{type:"array",required:!0,arrayItem:{required:!0,type:"object",properties:c(m({},l.properties),{userId:{required:!1,type:"string"},muteAudio:{type:"boolean"},muteVideo:{type:"boolean"},muteSubStream:{type:"boolean"}})}}}},E={name:"option",properties:m({},b.properties)};var u=class u{constructor(e){this.core=e;d(this,"connectedRoomIdSet",new Set);d(this,"updateSeq",0)}getName(){return u.Name}getAlias(){return"crs-r"}getGroup(e){var o;let r=(e==null?void 0:e.userId)||((o=e==null?void 0:e.updateList)==null?void 0:o[0].userId)||"";return r||(e?e.updateList?String(e.updateList[0].roomId)||e.updateList[0].strRoomId||"":String(e.roomId)||e.strRoomId||"":"*")}getValidateRule(e){switch(e){case"start":return l;case"update":return R;case"stop":return E}}async start({roomId:e,strRoomId:r,userId:o}){let{RtcError:t,ErrorCode:s}=this.core.errorModule;if(!this.core.room.sendSignalMessage)throw new t({code:s.ENV_NOT_SUPPORTED});let n=e||r,i=await this.core.room.sendSignalMessage({command:"connect_other_room",responseCommand:String(8209),data:{roomId:n,userId:o,localRoomId:o?void 0:this.core.room.roomId},retries:3});if(i.data.code!==0)throw new t({code:s.SERVER_ERROR,extraCode:i.data.code,message:i.data.message});o||this.connectedRoomIdSet.add(n)}async update({updateList:e}){var n;let{RtcError:r,ErrorCode:o}=this.core.errorModule;if(!this.core.room.sendSignalMessage)throw new r({code:o.ENV_NOT_SUPPORTED});let t=e.find(i=>i.userId)?0:1,s=await this.core.room.sendSignalMessage({command:"update_other_room_forward_mode",responseCommand:String(8213),data:{seq:++this.updateSeq,operationType:t,updateList:e.map(({roomId:i,strRoomId:g,userId:O,muteAudio:_,muteVideo:I,muteSubStream:A})=>({roomId:i||g,userId:O,muteAudio:_,muteVideo:I,muteSubStream:A}))},retries:3});if(s.data.data.expectSeq)return this.updateSeq=s.data.data.expectSeq,this.update({updateList:e});if(s.data.code!==0)throw new r({code:o.SERVER_ERROR,extraCode:s.data.code,message:s.data.message});if(((n=s.data.data.errorList)==null?void 0:n.length)>0)throw new r({code:o.UNKNOWN_ERROR,message:s.data.data.errorList[0].message})}async stop({roomId:e,strRoomId:r}={}){let o=e||r;if(o)await this.doStop(o);else if(this.connectedRoomIdSet.size>0)for(let t of[...this.connectedRoomIdSet.values()])await this.doStop(t);else await this.doStop()}async doStop(e){let{RtcError:r,ErrorCode:o}=this.core.errorModule;if(!this.core.room.sendSignalMessage)throw new r({code:o.ENV_NOT_SUPPORTED});let t=await this.core.room.sendSignalMessage({command:"disconnect_other_room",responseCommand:String(8211),data:{roomId:e,localRoomId:this.core.room.roomId},retries:3});if(t.data.code!==0)throw new r({code:o.SERVER_ERROR,extraCode:t.data.code,message:t.data.message});this.connectedRoomIdSet.delete(e)}destroy(){}};d(u,"Name","CrossRoom");var S=u;var G=S;export{S as CrossRoom,G as default};
